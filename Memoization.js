/*
Memoization: 记忆化斐波那契函数
斐波那契数列: 1,1,2,3,5,8,13, ... 即f(n) = f(n-1)+f(n-2);
题目: 完成Fibonacci函数 接收n为参数,获取数列中第n个数
 */

//直观写法: 利用递归 但是n很大的时候,计算时间很长,程序失去响应
const fibonacci1 = (n) => {
    return n < 3 ? 1 : fibonacci1(n-1) + fibonacci1(n-2);
};


//利用缓存,空间换时间,缓存已经计算的数列
const fibonacci2 = (n, cache = {}) => {
    if (n < 3) {
        return cache[n] = 1;
    }
    if (cache[n]) {
        return cache[n];
    }
    return cache[n] = fibonacci2(n-1, cache) + fibonacci2(n-2, cache);
};

//二次优化: 缓存cache在每次计算都需要访问,所以cache需要保存在内存中,通过构造闭包,让cache保存在闭包中
const fibonacci3 = ((cache = {}) => n => {
    if (cache[n]) {
        return cache[n];
    }
    if (n < 3) {
        return cache[n] = 1;
    }
    return cache[n] = fibonacci3(n-1) + fibonacci3(n-2);
})();

/**
 * 关于闭包,执行上下文, 作用域, this
 * 在JS执行一段段代码之前, 浏览器已经做了一些准备, 包括对变量,函数声明的声明, this和函数表达式的赋值
 * 这三种数据的准备就可以称为执行上下文, 如果要执行的代码段是函数,在上述三个的基础上还要加上以下:
 * 1. 函数参数赋值 2. 赋值arguments 3. 赋值自由变量的取值作用域
 * 所以执行上下文就是: 在执行代码之前,把所有要用的变量拿出来,直接赋值或者进行声明.
 * 函数每被调用一次, 就会产生一个新的上下文环境
 * 但是函数在定义的时候,就已经确定了函数内部自由变量的作用域
 * 关于函数中this的取值,首先确定一点, this的值是在函数被调用执行的时候确定,而不是函数定义的时候确定
 * 分为四种情况:
 * 1. 如果函数作为构造函数使用, this就代表new出来的对象
 * 2. 函数作为对象的一个属性,并且作为对象的一个属性被调用时, this指向该对象
 * 3, 在call和apply中, this就指向传入对象的值
 * 4. 全局: this指向window 普通函数在调用时, this也指向window
 * 除了全局作用域外,只有函数可以创建作用域, 作用域有着上下级的关系,关系 的确定就是看函数在哪个作用域下
 * 创建的, 作用域最大的用处就是隔离变量.
 * 作用域只是一个抽象的概念,没有变量,通过与作用域对应的执行上下环境来取得变量的值
 * 所以,要查找某一个作用域下的某个变量的值, 就需要找到这个作用域对应的上下文环境,然后在寻找变量的值
 * 对于在作用域中没有定义的值,就需要去创建这个函数的作用域中取值,
 *
 * 当一个函数被调用完成后, 执行上下文环境将被销毁, 其中保存的变量也会销毁, 但是有些情况下: 函数
 * 立即调用完成后, 执行上下文环境不会被立即销毁, 这就是闭包的核心内容
 * 因为返回的是函数,会创建一个作用域,里面包含对将要销毁上下文中变量的引用,所以不能删除,所以将要
 * 销毁的上下文环境变量还存在于上下文栈中, 所以使用闭包会增加内存开销.
 */
console.time('1')
console.log(fibonacci3(1000));
console.timeEnd('1');
